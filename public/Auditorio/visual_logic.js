/**
 * Generated by Verge3D Puzzles v.3.8.1
 * Thu Oct 28 2021 19:50:44 GMT-0500 (hora estándar de Perú)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

"use strict";

(function () {
  // global variables/constants used by puzzles' functions

  var LIST_NONE = "<none>";

  var _pGlob = {};

  _pGlob.objCache = {};
  _pGlob.fadeAnnotations = true;
  _pGlob.pickedObject = "";
  _pGlob.hoveredObject = "";
  _pGlob.mediaElements = {};
  _pGlob.loadedFile = "";
  _pGlob.states = [];
  _pGlob.percentage = 0;
  _pGlob.openedFile = "";
  _pGlob.xrSessionAcquired = false;
  _pGlob.xrSessionCallbacks = [];
  _pGlob.screenCoords = new v3d.Vector2();
  _pGlob.intervalTimers = {};

  _pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
  _pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
  _pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
  _pGlob.MIN_DRAG_SCALE = 10e-4;
  _pGlob.SET_OBJ_ROT_EPS = 1e-8;

  _pGlob.vec2Tmp = new v3d.Vector2();
  _pGlob.vec2Tmp2 = new v3d.Vector2();
  _pGlob.vec3Tmp = new v3d.Vector3();
  _pGlob.vec3Tmp2 = new v3d.Vector3();
  _pGlob.vec3Tmp3 = new v3d.Vector3();
  _pGlob.vec3Tmp4 = new v3d.Vector3();
  _pGlob.eulerTmp = new v3d.Euler();
  _pGlob.eulerTmp2 = new v3d.Euler();
  _pGlob.quatTmp = new v3d.Quaternion();
  _pGlob.quatTmp2 = new v3d.Quaternion();
  _pGlob.colorTmp = new v3d.Color();
  _pGlob.mat4Tmp = new v3d.Matrix4();
  _pGlob.planeTmp = new v3d.Plane();
  _pGlob.raycasterTmp = new v3d.Raycaster();

  var PL = (v3d.PL = v3d.PL || {});

  // a more readable alias for PL (stands for "Puzzle Logic")
  v3d.puzzles = PL;

  PL.procedures = PL.procedures || {};

  PL.execInitPuzzles = function (options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
      initOptions: {
        fadeAnnotations: true,
        useBkgTransp: false,
        preserveDrawBuf: false,
        useCompAssets: false,
        useFullscreen: true,
        useCustomPreloader: false,
        preloaderStartCb: function () {},
        preloaderProgressCb: function () {},
        preloaderEndCb: function () {},
      },
    };

    // provide the container's id to puzzles that need access to the container
    _initGlob.container =
      options !== undefined && "container" in options ? options.container : "";

    var PROC = {};

    // utility functions envoked by the HTML puzzles
    function getElements(ids, isParent) {
      var elems = [];
      if (
        Array.isArray(ids) &&
        ids[0] != "CONTAINER" &&
        ids[0] != "WINDOW" &&
        ids[0] != "DOCUMENT" &&
        ids[0] != "BODY" &&
        ids[0] != "QUERYSELECTOR"
      ) {
        for (var i = 0; i < ids.length; i++)
          elems.push(getElement(ids[i], isParent));
      } else {
        elems.push(getElement(ids, isParent));
      }
      return elems;
    }

    function getElement(id, isParent) {
      var elem;
      if (Array.isArray(id) && id[0] == "CONTAINER") {
        if (appInstance !== null) {
          elem = appInstance.container;
        } else if (typeof _initGlob !== "undefined") {
          // if we are on the initialization stage, we still can have access
          // to the container element
          var id = _initGlob.container;
          if (isParent) {
            elem = parent.document.getElementById(id);
          } else {
            elem = document.getElementById(id);
          }
        }
      } else if (Array.isArray(id) && id[0] == "WINDOW") {
        if (isParent) elem = parent;
        else elem = window;
      } else if (Array.isArray(id) && id[0] == "DOCUMENT") {
        if (isParent) elem = parent.document;
        else elem = document;
      } else if (Array.isArray(id) && id[0] == "BODY") {
        if (isParent) elem = parent.document.body;
        else elem = document.body;
      } else if (Array.isArray(id) && id[0] == "QUERYSELECTOR") {
        if (isParent) elem = parent.document.querySelector(id);
        else elem = document.querySelector(id);
      } else {
        if (isParent) elem = parent.document.getElementById(id);
        else elem = document.getElementById(id);
      }
      return elem;
    }

    // setHTMLElemAttribute puzzle
    function setHTMLElemAttribute(attr, value, ids, isParent) {
      var elems = getElements(ids, isParent);
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if (attr === "style") {
          // NOTE: setting an attribute 'style' instead of a property 'style'
          // fixes IE11 worng behavior
          elem.setAttribute(attr, value);
        } else {
          elem[attr] = value;
        }
      }
    }

    // setHTMLElemStyle puzzle
    function setHTMLElemStyle(prop, value, ids, isParent) {
      var elems = getElements(ids, isParent);
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style) continue;
        elem.style[prop] = value;
      }
    }

    // initSettings puzzle
    _initGlob.output.initOptions.fadeAnnotations = true;
    _initGlob.output.initOptions.useBkgTransp = false;
    _initGlob.output.initOptions.preserveDrawBuf = false;
    _initGlob.output.initOptions.useCompAssets = true;
    _initGlob.output.initOptions.useFullscreen = false;

    // initPreloader puzzle
    _initGlob.output.initOptions.useCustomPreloader = true;
    _initGlob.output.initOptions.preloaderStartCb = function () {
      _initGlob.percentage = 0;
      (function () {})();
    };
    _initGlob.output.initOptions.preloaderProgressCb = function (percentage) {
      _initGlob.percentage = percentage;
      (function () {
        setHTMLElemAttribute(
          "innerHTML",
          String(Math.round(_initGlob.percentage)) + "%",
          "percentage",
          false
        );
        setHTMLElemAttribute(
          "style",
          [
            "stroke-dashoffset: ",
            472 - (472 * Math.round(_initGlob.percentage)) / 100,
            ";",
          ].join(""),
          "circle",
          false
        );
      })();
    };
    _initGlob.output.initOptions.preloaderEndCb = function () {
      _initGlob.percentage = 100;
      (function () {
        setHTMLElemStyle("display", "none", "preloader_screen", false);
      })();
    };

    return _initGlob.output;
  };

  PL.init = function (appInstance, initOptions) {
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = appInstance;

    initOptions = initOptions || {};

    if ("fadeAnnotations" in initOptions) {
      _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
    }

    var PROC = {};

    var boolInformacion, video;

    // utility function envoked by almost all V3D-specific puzzles
    // filter off some non-mesh types
    function notIgnoredObj(obj) {
      return (
        obj.type !== "AmbientLight" &&
        obj.name !== "" &&
        !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
        !obj.isAuxClippingMesh
      );
    }

    // utility function envoked by almost all V3D-specific puzzles
    // find first occurence of the object by its name
    function getObjectByName(objName) {
      var objFound;
      var runTime = _pGlob !== undefined;
      objFound = runTime ? _pGlob.objCache[objName] : null;

      if (objFound && objFound.name === objName) return objFound;

      appInstance.scene.traverse(function (obj) {
        if (!objFound && notIgnoredObj(obj) && obj.name == objName) {
          objFound = obj;
          if (runTime) {
            _pGlob.objCache[objName] = objFound;
          }
        }
      });
      return objFound;
    }

    // utility function envoked by almost all V3D-specific puzzles
    // retrieve all objects on the scene
    function getAllObjectNames() {
      var objNameList = [];
      appInstance.scene.traverse(function (obj) {
        if (notIgnoredObj(obj)) objNameList.push(obj.name);
      });
      return objNameList;
    }

    // utility function envoked by almost all V3D-specific puzzles
    // retrieve all objects which belong to the group
    function getObjectNamesByGroupName(targetGroupName) {
      var objNameList = [];
      appInstance.scene.traverse(function (obj) {
        if (notIgnoredObj(obj)) {
          var groupNames = obj.groupNames;
          if (!groupNames) return;
          for (var i = 0; i < groupNames.length; i++) {
            var groupName = groupNames[i];
            if (groupName == targetGroupName) {
              objNameList.push(obj.name);
            }
          }
        }
      });
      return objNameList;
    }

    // utility function envoked by almost all V3D-specific puzzles
    // process object input, which can be either single obj or array of objects, or a group
    function retrieveObjectNames(objNames) {
      var acc = [];
      retrieveObjectNamesAcc(objNames, acc);
      return acc.filter(function (name) {
        return name;
      });
    }

    function retrieveObjectNamesAcc(currObjNames, acc) {
      if (typeof currObjNames == "string") {
        acc.push(currObjNames);
      } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++) acc.push(newObj[i]);
      } else if (
        Array.isArray(currObjNames) &&
        currObjNames[0] == "ALL_OBJECTS"
      ) {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++) acc.push(newObj[i]);
      } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
          retrieveObjectNamesAcc(currObjNames[i], acc);
      }
    }

    // utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
    function initObjectPicking(
      callback,
      eventType,
      mouseDownUseTouchStart,
      mouseButtons
    ) {
      var elem = appInstance.renderer.domElement;
      elem.addEventListener(eventType, pickListener);
      if (v3d.PL.editorEventListeners)
        v3d.PL.editorEventListeners.push([elem, eventType, pickListener]);

      if (eventType == "mousedown") {
        var touchEventName = mouseDownUseTouchStart ? "touchstart" : "touchend";
        elem.addEventListener(touchEventName, pickListener);
        if (v3d.PL.editorEventListeners)
          v3d.PL.editorEventListeners.push([
            elem,
            touchEventName,
            pickListener,
          ]);
      } else if (eventType == "dblclick") {
        var prevTapTime = 0;

        function doubleTapCallback(event) {
          var now = new Date().getTime();
          var timesince = now - prevTapTime;

          if (timesince < 600 && timesince > 0) {
            pickListener(event);
            prevTapTime = 0;
            return;
          }

          prevTapTime = new Date().getTime();
        }

        var touchEventName = mouseDownUseTouchStart ? "touchstart" : "touchend";
        elem.addEventListener(touchEventName, doubleTapCallback);
        if (v3d.PL.editorEventListeners)
          v3d.PL.editorEventListeners.push([
            elem,
            touchEventName,
            doubleTapCallback,
          ]);
      }

      var raycaster = new v3d.Raycaster();

      function pickListener(event) {
        // to handle unload in loadScene puzzle
        if (!appInstance.getCamera()) return;

        event.preventDefault();

        var xNorm = 0,
          yNorm = 0;
        if (event instanceof MouseEvent) {
          if (mouseButtons && mouseButtons.indexOf(event.button) == -1) return;
          xNorm = event.offsetX / elem.clientWidth;
          yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
          var rect = elem.getBoundingClientRect();
          xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
          yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
        raycaster.setFromCamera(
          _pGlob.screenCoords,
          appInstance.getCamera(true)
        );
        var objList = [];
        appInstance.scene.traverse(function (obj) {
          objList.push(obj);
        });
        var intersects = raycaster.intersectObjects(objList);
        callback(intersects, event);
      }
    }

    function objectsIncludeObj(objNames, testedObjName) {
      if (!testedObjName) return false;

      for (var i = 0; i < objNames.length; i++) {
        if (testedObjName == objNames[i]) {
          return true;
        } else {
          // also check children which are auto-generated for multi-material objects
          var obj = getObjectByName(objNames[i]);
          if (obj && obj.type == "Group") {
            for (var j = 0; j < obj.children.length; j++) {
              if (testedObjName == obj.children[j].name) {
                return true;
              }
            }
          }
        }
      }
      return false;
    }

    // utility function used by the whenClicked, whenHovered, whenDraggedOver, and raycast puzzles
    function getPickedObjectName(obj) {
      // auto-generated from a multi-material object, use parent name instead
      if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
        return obj.parent.name;
      } else {
        return obj.name;
      }
    }

    function eventGetOffsetCoords(e, touchId, dest) {
      if (e instanceof MouseEvent) {
        dest.set(e.offsetX, e.offsetY);
      } else if (window.TouchEvent && e instanceof TouchEvent) {
        var rect = e.target.getBoundingClientRect();
        var touches = e.touches;
        if (
          e.type == "touchstart" ||
          e.type == "touchend" ||
          e.type == "touchmove"
        ) {
          touches = e.changedTouches;
        }

        var touch = touches[0];
        for (var i = 0; i < touches.length; i++) {
          if (touches[i].identifier == touchId) {
            touch = touches[i];
            break;
          }
        }

        dest.set(touch.clientX - rect.left, touch.clientY - rect.top);
      }
      return dest;
    }

    function eventTouchIdGetFirst(e) {
      if (e instanceof MouseEvent) {
        return -1;
      } else if (window.TouchEvent && e instanceof TouchEvent) {
        if (
          e.type == "touchstart" ||
          e.type == "touchend" ||
          e.type == "touchmove"
        ) {
          return e.changedTouches[0].identifier;
        } else {
          return e.touches[0].identifier;
        }
      }
      return -1;
    }

    /**
     * For "touchstart", "touchend" and "touchmove" events returns true if a touch
     * object with the provided touch id is in the changedTouches array, otherwise
     * - false. For other events returns true.
     */
    function eventTouchIdChangedFilter(e, touchId) {
      if (window.TouchEvent && e instanceof TouchEvent) {
        if (
          e.type == "touchstart" ||
          e.type == "touchend" ||
          e.type == "touchmove"
        ) {
          var isChanged = false;
          for (var i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier == touchId) {
              isChanged = true;
              break;
            }
          }
          return isChanged;
        }
      }

      return true;
    }

    function initDragOverInfo() {
      return {
        draggedObjName: "",
        downX: 0,
        downY: 0,
        prevX: 0,
        prevY: 0,
        currX: 0,
        currY: 0,
        isDowned: false,
        isMoved: false,
        touchId: -1,
      };
    }

    // whenDraggedOver puzzle
    _pGlob.objDragOverInfoGlobal = [];
    _pGlob.objDragOverInfoByBlock = {};

    initObjectPicking(
      function (intersects, downEvent) {
        _pGlob.objDragOverInfoGlobal.forEach(function (el) {
          if (downEvent instanceof MouseEvent)
            if (el.mouseButtons.indexOf(downEvent.button) == -1) return;

          var maxIntersects = el.xRay
            ? intersects.length
            : Math.min(1, intersects.length);

          for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);

            if (objectsIncludeObj([el.objName], objName)) {
              el.callback({ downEvent: downEvent, draggedObjName: objName });
            }
          }
        });
      },
      "mousedown",
      true
    );

    // whenDraggedOver puzzle
    function registerOnDrag(
      objSelector,
      xRay,
      mouseButtons,
      cbStart,
      cbMove,
      cbDrop,
      blockId
    ) {
      var cb = function (cbParam) {
        if (appInstance.controls) {
          appInstance.controls.enabled = false;
        }

        if (!(blockId in _pGlob.objDragOverInfoByBlock)) {
          _pGlob.objDragOverInfoByBlock[blockId] = initDragOverInfo();
        }
        var info = _pGlob.objDragOverInfoByBlock[blockId];

        // NOTE: don't use more than one pointing event, e.g. don't process
        // some events related to multitouch actions
        if (info.isDowned) {
          return;
        }

        var touchId = eventTouchIdGetFirst(cbParam.downEvent);
        var coords = eventGetOffsetCoords(
          cbParam.downEvent,
          touchId,
          _pGlob.vec2Tmp
        );

        info.downX = info.prevX = info.currX = coords.x;
        info.downY = info.prevY = info.currY = coords.y;
        info.touchId = touchId;
        info.isDowned = true;
        info.isMoved = false;
        info.draggedObjName = cbParam.draggedObjName;

        cbStart(cbParam.downEvent);

        var elem = appInstance.container;

        var moveCb = function (e) {
          if (!eventTouchIdChangedFilter(e, info.touchId)) {
            // don't handle events not intended for this particular touch
            return;
          }

          var coords = eventGetOffsetCoords(e, info.touchId, _pGlob.vec2Tmp);
          info.prevX = info.currX;
          info.prevY = info.currY;
          info.currX = coords.x;
          info.currY = coords.y;
          cbMove(e);
          info.isMoved = true;
        };
        var upCb = function (e) {
          if (!eventTouchIdChangedFilter(e, info.touchId)) {
            // don't handle events not intended for this particular touch
            return;
          }

          var coords = eventGetOffsetCoords(e, info.touchId, _pGlob.vec2Tmp);
          info.currX = coords.x;
          info.currY = coords.y;
          info.prevX = info.currX;
          info.prevY = info.currY;
          cbDrop(e);
          info.isDowned = false;

          elem.removeEventListener("mousemove", moveCb);
          elem.removeEventListener("touchmove", moveCb);
          elem.removeEventListener("mouseup", upCb);
          elem.removeEventListener("touchend", upCb);
          if (appInstance.controls) {
            appInstance.controls.enabled = true;
          }
        };

        elem.addEventListener("mousemove", moveCb);
        elem.addEventListener("touchmove", moveCb);
        elem.addEventListener("mouseup", upCb);
        elem.addEventListener("touchend", upCb);
      };

      var objNames = retrieveObjectNames(objSelector);

      for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        _pGlob.objDragOverInfoGlobal.push({
          objName: objName,
          callback: cb,
          xRay: xRay,
          mouseButtons: mouseButtons,
        });
      }
    }

    // callJSFunction puzzle
    function getJSFunction(funcName) {
      var jsFunc = appInstance.ExternalInterface[funcName];
      if (typeof jsFunc == "function") return jsFunc;
      else return function () {};
    }

    // setTimeout puzzle
    function registerSetTimeout(timeout, callback) {
      window.setTimeout(callback, 1000 * timeout);
    }

    // whenClicked puzzle
    function registerOnClick(
      objSelector,
      xRay,
      doubleClick,
      mouseButtons,
      cbDo,
      cbIfMissedDo
    ) {
      // for AR/VR
      _pGlob.objClickInfo = _pGlob.objClickInfo || [];

      _pGlob.objClickInfo.push({
        objSelector: objSelector,
        callbacks: [cbDo, cbIfMissedDo],
      });

      initObjectPicking(
        function (intersects, event) {
          var isPicked = false;

          var maxIntersects = xRay
            ? intersects.length
            : Math.min(1, intersects.length);

          for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);
            var objNames = retrieveObjectNames(objSelector);

            if (objectsIncludeObj(objNames, objName)) {
              // save the object for the pickedObject block
              _pGlob.pickedObject = objName;
              isPicked = true;
              cbDo(event);
            }
          }

          if (!isPicked) {
            _pGlob.pickedObject = "";
            cbIfMissedDo(event);
          }
        },
        doubleClick ? "dblclick" : "mousedown",
        false,
        mouseButtons
      );
    }

    // utility functions envoked by the HTML puzzles
    function getElements(ids, isParent) {
      var elems = [];
      if (
        Array.isArray(ids) &&
        ids[0] != "CONTAINER" &&
        ids[0] != "WINDOW" &&
        ids[0] != "DOCUMENT" &&
        ids[0] != "BODY" &&
        ids[0] != "QUERYSELECTOR"
      ) {
        for (var i = 0; i < ids.length; i++)
          elems.push(getElement(ids[i], isParent));
      } else {
        elems.push(getElement(ids, isParent));
      }
      return elems;
    }

    function getElement(id, isParent) {
      var elem;
      if (Array.isArray(id) && id[0] == "CONTAINER") {
        if (appInstance !== null) {
          elem = appInstance.container;
        } else if (typeof _initGlob !== "undefined") {
          // if we are on the initialization stage, we still can have access
          // to the container element
          var id = _initGlob.container;
          if (isParent) {
            elem = parent.document.getElementById(id);
          } else {
            elem = document.getElementById(id);
          }
        }
      } else if (Array.isArray(id) && id[0] == "WINDOW") {
        if (isParent) elem = parent;
        else elem = window;
      } else if (Array.isArray(id) && id[0] == "DOCUMENT") {
        if (isParent) elem = parent.document;
        else elem = document;
      } else if (Array.isArray(id) && id[0] == "BODY") {
        if (isParent) elem = parent.document.body;
        else elem = document.body;
      } else if (Array.isArray(id) && id[0] == "QUERYSELECTOR") {
        if (isParent) elem = parent.document.querySelector(id);
        else elem = document.querySelector(id);
      } else {
        if (isParent) elem = parent.document.getElementById(id);
        else elem = document.getElementById(id);
      }
      return elem;
    }

    // setHTMLElemStyle puzzle
    function setHTMLElemStyle(prop, value, ids, isParent) {
      var elems = getElements(ids, isParent);
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style) continue;
        elem.style[prop] = value;
      }
    }

    // eventHTMLElem puzzle
    function eventHTMLElem(eventType, ids, isParent, callback) {
      var elems = getElements(ids, isParent);
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;
        elem.addEventListener(eventType, callback);
        if (v3d.PL.editorEventListeners)
          v3d.PL.editorEventListeners.push([elem, eventType, callback]);
      }
    }

    // openWebPage puzzle
    function openWebPage(url, mode) {
      if (appInstance && appInstance.controls) {
        appInstance.controls.forceMouseUp();
      }

      if (mode == "NEW") {
        window.open(url);
      } else if (mode == "NO_RELOAD") {
        history.pushState("verge3d state", "verge3d page", url);
      } else {
        var target;
        switch (mode) {
          case "SAME":
            target = "_self";
            break;
          case "TOP":
            target = "_top";
            break;
          case "PARENT":
            target = "_parent";
            break;
        }
        if (typeof window.PE != "undefined") {
          if (window.confirm("Are you sure you want to leave Puzzles?"))
            window.open(url, target);
        } else {
          window.open(url, target);
        }
      }
    }

    // outline puzzle
    function outline(objSelector, doWhat) {
      var objNames = retrieveObjectNames(objSelector);

      if (
        !appInstance.postprocessing ||
        !appInstance.postprocessing.outlinePass
      )
        return;
      var outlineArray = appInstance.postprocessing.outlinePass.selectedObjects;
      for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        var obj = getObjectByName(objName);
        if (!obj) continue;
        if (doWhat == "ENABLE") {
          if (outlineArray.indexOf(obj) == -1) outlineArray.push(obj);
        } else {
          var index = outlineArray.indexOf(obj);
          if (index > -1) outlineArray.splice(index, 1);
        }
      }
    }

    // whenHovered puzzle
    initObjectPicking(
      function (intersects, event) {
        var prevHovered = _pGlob.hoveredObject;
        var currHovered = "";

        // the event might happen before hover registration
        _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

        // search for closest hovered object

        var lastIntersectIndex = Infinity;
        _pGlob.objHoverInfo.forEach(function (el) {
          var maxIntersects = el.xRay
            ? intersects.length
            : Math.min(1, intersects.length);

          for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);

            if (
              objectsIncludeObj(retrieveObjectNames(el.objSelector), objName) &&
              i <= lastIntersectIndex
            ) {
              currHovered = objName;
              lastIntersectIndex = i;
            }
          }
        });

        if (prevHovered == currHovered) return;

        // first - all "out" callbacks, then - all "over"
        _pGlob.objHoverInfo.forEach(function (el) {
          if (
            objectsIncludeObj(retrieveObjectNames(el.objSelector), prevHovered)
          ) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = prevHovered;
            el.callbacks[1](event);
          }
        });

        _pGlob.objHoverInfo.forEach(function (el) {
          if (
            objectsIncludeObj(retrieveObjectNames(el.objSelector), currHovered)
          ) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = currHovered;
            el.callbacks[0](event);
          }
        });

        _pGlob.hoveredObject = currHovered;
      },
      "mousemove",
      false
    );

    // whenHovered puzzle
    function registerOnHover(objSelector, xRay, cbOver, cbOut) {
      _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

      _pGlob.objHoverInfo.push({
        objSelector: objSelector,
        callbacks: [cbOver, cbOut],
        xRay: xRay,
      });
    }

    registerOnDrag(
      ["play_mesh", "tv_auditorio"],
      false,
      [0, 1, 2],
      function () {},
      function () {},
      function () {},
      "9lP2V$u.zCG)fCo$Ia{s"
    );

    registerOnClick(
      ["play_mesh", "tv_auditorio"],
      false,
      false,
      [0, 1, 2],
      function () {
        registerSetTimeout(1, function () {
          getJSFunction("VideoYoutubeVerge")(true);
        });
      },
      function () {}
    );

    boolInformacion = false;
    setHTMLElemStyle("display", "none", "bgInformacion", false);
    setHTMLElemStyle("display", "flex", "informacion", false);
    eventHTMLElem("click", "informacion", false, function (event) {
      if (boolInformacion == false) {
        setHTMLElemStyle("display", "flex", "bgInformacion", false);
        boolInformacion = true;
      } else if (boolInformacion == true) {
        setHTMLElemStyle("display", "none", "bgInformacion", false);
        boolInformacion = false;
      }
    });
    eventHTMLElem("click", "CerrarInformacion", false, function (event) {
      setHTMLElemStyle("display", "none", "bgInformacion", false);
      boolInformacion = false;
    });

    eventHTMLElem("click", "feria3d", false, function (event) {
      openWebPage("/convention", "SAME");
    });

    registerOnHover(
      "play_mesh",
      false,
      function () {
        outline("play_mesh", "ENABLE");
      },
      function () {
        outline("play_mesh", "DISABLE");
      }
    );
  }; // end of PL.init function
})(); // end of closure

/* ================================ end of code ============================= */
